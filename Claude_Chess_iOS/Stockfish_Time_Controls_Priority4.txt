# Stockfish Time Controls Integration - Priority 4 Analysis

## Problem Statement

**User Observation:** When testing against reference Stockfish 17.1 chess app,
our AI burns through its time allocation WAY faster than the reference app,
despite both using Stockfish 17.1 engine at similar skill levels.

**Example:**
- Our app: 5 minute allocation consumed in ~10-15 moves
- Reference app: 5 minute allocation lasts 30-40+ moves
- Our terminal app: Time consumption similar to reference app (reasonable)

## Root Cause Analysis

### Current Implementation (Depth-Based Search)

**File:** `StockfishEngine.swift` - `getBestMove()` method

```swift
// Current code (Session 17):
if is_time_control_enabled(game) {
    // TIME-BASED: Not yet implemented, falls through to depth
} else {
    // DEPTH-BASED: Always uses this currently
    let searchDepth = calculateSearchDepth(for: skillLevel)
    await engine.send(command: .go(depth: searchDepth))
}
```

**Depth mapping (from calculateSearchDepth):**
- Skill 5 → Depth 3
- Skill 10 → Depth 7
- Skill 15 → Depth 11
- Skill 20 → Depth 15

**Problem:**
- Depth-based search means Stockfish searches ALL positions to depth N
- Higher depths (11-15) can take **3-10 seconds per move** depending on
  position complexity
- No concept of "hurry up, you're low on time"
- 5 minutes = 300 seconds ÷ 5 seconds/move = only 60 moves total
- With opening/middlegame taking longer, clock burns fast

### Reference App Implementation (Time-Based Search)

**Likely code in reference app:**
```swift
// Fixed time per move (e.g., 1-2 seconds)
await engine.send(command: .go(movetime: 1000))  // 1 second

// OR proportional to remaining time:
let moveTime = (timeRemaining / 20)  // Use 1/20th of clock
await engine.send(command: .go(movetime: moveTime))
```

**Advantages:**
- Moves complete in predictable time
- Clock consumption proportional and sustainable
- As time pressure increases, moves get faster
- 5 minutes lasts entire game (30-50 moves easily)

### Terminal App Implementation (Reference)

**File:** `../stockfish.c` - Terminal project implementation

```c
// From terminal CLAUDE.md - Time Controls System section:
if (is_time_control_enabled(game)) {
    // TIME-BASED SEARCH: Use actual time allocation
    int time_remaining = (game->current_player == WHITE) ?
                       game->timer.white_time_seconds :
                       game->timer.black_time_seconds;

    // Use ~1/20th of remaining time (min 500ms, max 10s)
    int move_time = (time_remaining * 1000) / 20;
    if (move_time < 500) move_time = 500;
    if (move_time > 10000) move_time = 10000;

    sprintf(go_command, "go movetime %d", move_time);
    send_command(engine, go_command);
} else {
    // DEPTH-BASED SEARCH: Fast, consistent difficulty
    send_command(engine, "go depth 10");
}
```

**Key Logic:**
1. Check if time controls enabled
2. Get remaining time for current player
3. Calculate move time as 1/20th of remaining time
4. Clamp to reasonable bounds (500ms min, 10s max)
5. Send UCI "go movetime" command with milliseconds

**Why this works:**
- Early game: 5 min = 300s, 300/20 = 15s per move (thoughtful)
- Mid game: 3 min = 180s, 180/20 = 9s per move (careful)
- Time pressure: 30s left, 30/20 = 1.5s per move (fast)
- Emergency: 10s left, 10/20 = 0.5s, clamped to 500ms minimum
- Never exceeds 10s cap (prevents single move burning huge time)

## Solution: iOS Implementation

### Code Changes Required

**File:** `StockfishEngine.swift` - Update `getBestMove()` method

**Current partial implementation:**
```swift
func getBestMove(for game: ChessGame) async throws -> Move? {
    // ... existing setup code ...

    // TODO: Check if time controls enabled
    if is_time_control_enabled(game) {
        // TIME-BASED SEARCH: Use actual time allocation
        // NOT YET IMPLEMENTED - falls through to depth
    } else {
        // DEPTH-BASED SEARCH: Fast, consistent difficulty
        let searchDepth = calculateSearchDepth(for: skillLevel)
        await engine.send(command: .go(depth: searchDepth))
    }
}
```

**Updated implementation:**
```swift
func getBestMove(for game: ChessGame) async throws -> Move? {
    // ... existing setup code ...

    // Check if time controls are enabled and active
    if game.timeControl.enabled && game.timer.timingActive {
        // TIME-BASED SEARCH: Use actual time allocation (terminal parity)

        // Get remaining time for current player (in seconds)
        let timeRemaining = (game.currentPlayer == .white)
            ? game.timer.whiteTimeSeconds
            : game.timer.blackTimeSeconds

        // Calculate move time: 1/20th of remaining time
        var moveTime = (timeRemaining * 1000) / 20  // Convert to milliseconds

        // Clamp to reasonable bounds (terminal project logic)
        if moveTime < 500 { moveTime = 500 }      // Minimum 500ms
        if moveTime > 10000 { moveTime = 10000 }  // Maximum 10 seconds

        print("DEBUG: Time-based search - Remaining: \(timeRemaining)s, "
              + "Using: \(moveTime)ms")

        await engine.send(command: .go(movetime: moveTime))

    } else {
        // DEPTH-BASED SEARCH: Fast, consistent difficulty (no time controls)
        let searchDepth = calculateSearchDepth(for: skillLevel)

        print("DEBUG: Depth-based search - Using depth: \(searchDepth)")

        await engine.send(command: .go(depth: searchDepth))
    }

    // ... rest of existing code ...
}
```

### Integration Points

**ChessGame Properties Needed:**
```swift
// Already exist in ChessGame.swift (Session 15):
struct TimeControl {
    var enabled: Bool
    // ... other properties
}

struct GameTimer {
    var whiteTimeSeconds: Int
    var blackTimeSeconds: Int
    var timingActive: Bool
    // ... other properties
}
```

**No new properties needed** - everything already exists from Session 15!

### Testing Protocol

**Test 1: Time Controls Disabled (0/0)**
- Expected: Depth-based search (current behavior)
- AI should think consistent time at each skill level
- No time deduction

**Test 2: Time Controls Enabled (5/0 - Blitz)**
- Expected: Time-based search, proportional thinking
- Early game moves: ~15 seconds each (300s / 20 = 15s, clamped to 10s)
- Mid game: ~5-9 seconds per move
- Time pressure (<30s): ~500ms-1.5s per move
- Clock should last 30-50 moves minimum

**Test 3: Time Controls Enabled (30/10 - Rapid)**
- Expected: Time-based search with increment
- Moves should average 60-90 seconds early game (1800s / 20 = 90s, clamped
  to 10s)
- After increment, effective time increases
- Clock should never run out in normal game

**Test 4: Skill Level Independence**
- Test at skill 5, 10, 15, 20
- Expected: All use same time calculation
- Skill affects move QUALITY, not move SPEED
- Time consumption should be identical across skill levels

### Expected Benefits

**User Experience:**
- AI moves at reasonable speed with time controls
- Time consumption matches reference apps
- 5/0 games actually playable (clock lasts full game)
- Time pressure creates exciting endgames
- Matches terminal app behavior

**Terminal Project Parity:**
- ✅ Same time calculation algorithm (1/20th)
- ✅ Same clamping logic (500ms min, 10s max)
- ✅ Same mode switching (time vs depth)
- ✅ Skill level affects search depth when no time controls

## Implementation Checklist

- [ ] Update `getBestMove()` in StockfishEngine.swift with time-based logic
- [ ] Add debug logging for time calculations
- [ ] Test with time controls disabled (depth-based still works)
- [ ] Test with 5/0 time controls (AI doesn't burn through clock)
- [ ] Test with 30/10 time controls (increment works correctly)
- [ ] Test at multiple skill levels (5, 10, 15, 20)
- [ ] Verify time deduction happens after AI moves
- [ ] Compare time consumption to reference Stockfish app
- [ ] Compare time consumption to terminal app
- [ ] Remove debug logging once verified working
- [ ] Update CLAUDE.md Session documentation
- [ ] Update Implementation Progress (mark time integration complete)

## Terminal Project References

**File:** `../CLAUDE.md`

**Relevant Sections:**
1. "Time Controls System (Complete Implementation)" - Line ~490
2. "Timer Control Features" - Line ~650
3. "Intelligent Stockfish Search Mode Selection" - Line ~680

**Key Quote from Terminal CLAUDE.md:**
```
// Use ~1/20th of remaining time (min 500ms, max 10s)
int move_time = (time_remaining * 1000) / 20;
if (move_time < 500) move_time = 500;
if (move_time > 10000) move_time = 10000;
```

This is the EXACT algorithm to port to iOS.

## Notes

- This is **Priority 4** in Session 18 agenda (if time permits)
- Can be deferred to Session 19 if evaluation/hints/stats take full session
- No UI changes needed - all backend logic
- Zero new dependencies or models needed
- Should be ~20 lines of code change in one method
- High impact on gameplay quality with time controls

---
**Feed this file back when implementing Priority 4 or in future session!**
